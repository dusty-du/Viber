name: Build Release App Bundle

on:
  release:
    types: [published]
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Xcode version
        run: xcodebuild -version

      - name: Build app bundle
        run: ./create-app-bundle.sh

      - name: Zip app bundle
        run: |
          ditto -c -k --sequesterRsrc --keepParent VibeProxy.app VibeProxy.app.zip

      - name: Checkout main for appcast update
        run: |
          git fetch origin main
          git checkout main

      - name: Generate signed appcast entry
        env:
          SPARKLE_ED25519_PRIVATE_KEY: ${{ secrets.SPARKLE_ED25519_PRIVATE_KEY }}
          RELEASE_TAG: ${{ github.ref_name }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          set -euo pipefail
          if [ -z "${SPARKLE_ED25519_PRIVATE_KEY:-}" ]; then
            echo "Missing SPARKLE_ED25519_PRIVATE_KEY secret"
            exit 1
          fi

          KEY_FILE="$(mktemp)"
          printf "%s" "$SPARKLE_ED25519_PRIVATE_KEY" > "$KEY_FILE"

          curl -L -o sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.5.0/Sparkle-2.5.0.tar.xz
          tar -xf sparkle.tar.xz

          SIGN_TOOL=""
          if [ -x "./bin/sign_update" ]; then
            SIGN_TOOL="./bin/sign_update"
          else
            SIGN_TOOL="$(find . -maxdepth 4 -type f -path "*/bin/sign_update" | head -1)"
          fi
          if [ -z "$SIGN_TOOL" ]; then
            echo "sign_update not found after extracting Sparkle"
            find . -maxdepth 4 -type f -name sign_update
            exit 1
          fi

          SIGN_OUTPUT="$("$SIGN_TOOL" --ed-key-file "$KEY_FILE" VibeProxy.app.zip)"
          export ED_SIGNATURE="$(echo "$SIGN_OUTPUT" | sed -n 's/.*sparkle:edSignature="\\([^"]*\\)".*/\\1/p')"
          export FILE_LENGTH="$(echo "$SIGN_OUTPUT" | sed -n 's/.*length="\\([0-9]*\\)".*/\\1/p')"

          if [ -z "$ED_SIGNATURE" ] || [ -z "$FILE_LENGTH" ]; then
            echo "Failed to parse sign_update output"
            echo "$SIGN_OUTPUT"
            exit 1
          fi

          python3 - <<'PY'
          import datetime
          import os
          import re

          tag = os.environ["RELEASE_TAG"]
          version = tag.lstrip("v")
          build = os.environ.get("GITHUB_RUN_NUMBER", "1")
          url = f"https://github.com/dusty-du/Viber/releases/download/{tag}/VibeProxy.app.zip"
          ed_sig = os.environ["ED_SIGNATURE"]
          length = os.environ["FILE_LENGTH"]

          pub_date = datetime.datetime.utcnow().strftime("%a, %d %b %Y %H:%M:%S +0000")
          min_system = "26.1"

          item = (
            "    <item>\n"
            f"      <title>Version {version}</title>\n"
            f"      <sparkle:version>{build}</sparkle:version>\n"
            f"      <sparkle:shortVersionString>{version}</sparkle:shortVersionString>\n"
            f"      <sparkle:minimumSystemVersion>{min_system}</sparkle:minimumSystemVersion>\n"
            f"      <pubDate>{pub_date}</pubDate>\n"
            f"      <enclosure url=\"{url}\"\n"
            "                 type=\"application/octet-stream\"\n"
            f"                 sparkle:edSignature=\"{ed_sig}\"\n"
            f"                 length=\"{length}\"/>\n"
            "    </item>\n"
          )

          with open("appcast.xml", "r", encoding="utf-8") as f:
            content = f.read()

          if f"<sparkle:shortVersionString>{version}</sparkle:shortVersionString>" in content:
            print("Appcast already contains this version; skipping update.")
            raise SystemExit(0)

          language_match = re.search(r"(\\s*<language>.*?</language>\\s*)", content, flags=re.DOTALL)
          if language_match:
            insert_at = language_match.end(1)
            new_content = content[:insert_at] + "\n" + item + content[insert_at:]
          else:
            # If no <language> exists, insert before the first <item> if present, otherwise after <channel>.
            item_match = re.search(r"(\\s*<item>\\s*)", content)
            if item_match:
              insert_at = item_match.start(1)
              new_content = content[:insert_at] + item + content[insert_at:]
            else:
              channel_match = re.search(r"(\\s*<channel>\\s*)", content)
              if not channel_match:
                raise SystemExit("Could not find <channel> tag to insert after.")
              insert_at = channel_match.end(1)
              new_content = content[:insert_at] + "\n" + item + content[insert_at:]

          with open("appcast.xml", "w", encoding="utf-8") as f:
            f.write(new_content)
          PY

      - name: Commit appcast update
        run: |
          set -euo pipefail
          if git diff --quiet appcast.xml; then
            echo "No appcast changes to commit."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add appcast.xml
          git commit -m "Update appcast for ${{ github.ref_name }}"
          git push origin main

      - name: Upload to release (tag push)
        if: github.event_name == 'push'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          files: |
            VibeProxy.app.zip
            appcast.xml
          generate_release_notes: true

      - name: Upload to release (published release)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.release.tag_name }}
          files: VibeProxy.app.zip
