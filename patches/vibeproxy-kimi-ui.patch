--- a/src/Sources/AuthStatus.swift
+++ b/src/Sources/AuthStatus.swift
@@ -8,7 +8,8 @@
     case qwen
     case antigravity
     case zai
-    
+    case kimi
+
     var displayName: String {
         switch self {
         case .claude: return "Claude Code"
@@ -18,6 +19,7 @@
         case .qwen: return "Qwen"
         case .antigravity: return "Antigravity"
         case .zai: return "Z.AI GLM"
+        case .kimi: return "Kimi"
         }
     }
 }
@@ -30,12 +32,12 @@
     let type: ServiceType
     let expired: Date?
     let filePath: URL
-    
+
     var isExpired: Bool {
         guard let expired = expired else { return false }
         return expired < Date()
     }
-    
+
     var displayName: String {
         if let email = email, !email.isEmpty {
             return email
@@ -45,7 +47,7 @@
         }
         return id
     }
-    
+
     static func == (lhs: AuthAccount, rhs: AuthAccount) -> Bool {
         lhs.id == rhs.id
     }
@@ -55,7 +57,7 @@
 struct ServiceAccounts {
     var type: ServiceType
     var accounts: [AuthAccount] = []
-    
+
     var hasAccounts: Bool { !accounts.isEmpty }
     var activeCount: Int { accounts.filter { !$0.isExpired }.count }
     var expiredCount: Int { accounts.filter { $0.isExpired }.count }
@@ -63,7 +65,7 @@
 
 class AuthManager: ObservableObject {
     @Published var serviceAccounts: [ServiceType: ServiceAccounts] = [:]
-    
+
     private static let dateFormatters: [ISO8601DateFormatter] = {
         let withFractional = ISO8601DateFormatter()
         withFractional.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
@@ -71,35 +73,35 @@
         standard.formatOptions = [.withInternetDateTime]
         return [withFractional, standard]
     }()
-    
+
     init() {
         // Initialize empty accounts for all service types
         for type in ServiceType.allCases {
             serviceAccounts[type] = ServiceAccounts(type: type)
         }
     }
-    
+
     func accounts(for type: ServiceType) -> [AuthAccount] {
         serviceAccounts[type]?.accounts ?? []
     }
-    
+
     func hasAccounts(for type: ServiceType) -> Bool {
         serviceAccounts[type]?.hasAccounts ?? false
     }
-    
+
     func checkAuthStatus() {
         let authDir = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".cli-proxy-api")
-        
+
         // Build new accounts dictionary
         var newAccounts: [ServiceType: [AuthAccount]] = [:]
         for type in ServiceType.allCases {
             newAccounts[type] = []
         }
-        
+
         do {
             let files = try FileManager.default.contentsOfDirectory(at: authDir, includingPropertiesForKeys: nil)
             NSLog("[AuthStatus] Scanning %d files in auth directory", files.count)
-            
+
             for file in files where file.pathExtension == "json" {
                 NSLog("[AuthStatus] Checking file: %@", file.lastPathComponent)
                 guard let data = try? Data(contentsOf: file),
@@ -108,13 +110,13 @@
                       let serviceType = ServiceType(rawValue: type.lowercased()) else {
                     continue
                 }
-                
+
                 NSLog("[AuthStatus] Found type '%@' in %@", type, file.lastPathComponent)
-                
+
                 let email = json["email"] as? String
                 let login = json["login"] as? String
                 var expiredDate: Date?
-                
+
                 if let expiredStr = json["expired"] as? String {
                     for formatter in Self.dateFormatters {
                         if let date = formatter.date(from: expiredStr) {
@@ -123,7 +125,7 @@
                         }
                     }
                 }
-                
+
                 let account = AuthAccount(
                     id: file.lastPathComponent,
                     email: email,
@@ -132,11 +134,11 @@
                     expired: expiredDate,
                     filePath: file
                 )
-                
+
                 newAccounts[serviceType]?.append(account)
                 NSLog("[AuthStatus] Found %@ auth: %@", serviceType.displayName, account.displayName)
             }
-            
+
             // Update on main thread
             DispatchQueue.main.async {
                 for type in ServiceType.allCases {
@@ -155,7 +157,7 @@
             }
         }
     }
-    
+
     /// Delete a specific account's auth file
     func deleteAccount(_ account: AuthAccount) -> Bool {
         do {
--- a/src/Sources/ServerManager.swift
+++ b/src/Sources/ServerManager.swift
@@ -7,39 +7,39 @@
     private var head = 0
     private var tail = 0
     private(set) var count = 0
-    
+
     init(capacity: Int) {
         let safeCapacity = max(1, capacity)
         storage = Array(repeating: nil, count: safeCapacity)
     }
-    
+
     mutating func append(_ element: Element) {
         let capacity = storage.count
         storage[tail] = element
-        
+
         if count == capacity {
             head = (head + 1) % capacity
         } else {
             count += 1
         }
-        
+
         tail = (tail + 1) % capacity
     }
-    
+
     func elements() -> [Element] {
         let capacity = storage.count
         guard count > 0 else { return [] }
-        
+
         var result: [Element] = []
         result.reserveCapacity(count)
-        
+
         for index in 0..<count {
             let storageIndex = (head + index) % capacity
             if let value = storage[storageIndex] {
                 result.append(value)
             }
         }
-        
+
         return result
     }
 }
@@ -78,13 +87,13 @@
     private var logBuffer: RingBuffer<String>
     private let maxLogLines = 1000
     private let processQueue = DispatchQueue(label: "io.automaze.vibeproxy.server-process", qos: .userInitiated)
-    
+
     private enum Timing {
         static let readinessCheckDelay: TimeInterval = 1.0
         static let gracefulTerminationTimeout: TimeInterval = 2.0
         static let terminationPollInterval: TimeInterval = 0.05
     }
-    
+
     var onLogUpdate: (([String]) -> Void)?
 
     /// OAuth provider keys used in config.yaml oauth-excluded-models
@@ -94,7 +103,8 @@
         "gemini": "gemini-cli",
         "github-copilot": "github-copilot",
         "antigravity": "antigravity",
-        "qwen": "qwen"
+        "qwen": "qwen",
+        "kimi": "kimi"
     ]
 
     init() {
@@ -120,13 +131,13 @@
         _ = getConfigPath()
         addLog("Config updated (hot reload)")
     }
-    
+
     deinit {
         // Ensure cleanup on deallocation
         stop()
         killOrphanedProcesses()
     }
-    
+
     func start(completion: @escaping (Bool) -> Void) {
         guard !isRunning else {
             completion(true)
@@ -142,14 +153,14 @@
             completion(false)
             return
         }
-        
+
         let bundledPath = (resourcePath as NSString).appendingPathComponent("cli-proxy-api-plus")
         guard FileManager.default.fileExists(atPath: bundledPath) else {
             addLog("âŒ Error: cli-proxy-api-plus binary not found at \(bundledPath)")
             completion(false)
             return
         }
-        
+
         // Use config path (merged with Z.AI if keys exist)
         let configPath = getConfigPath()
         guard !configPath.isEmpty && FileManager.default.fileExists(atPath: configPath) else {
@@ -157,17 +168,17 @@
             completion(false)
             return
         }
-        
+
         process = Process()
         process?.executableURL = URL(fileURLWithPath: bundledPath)
         process?.arguments = ["-config", configPath]
-        
+
         // Setup pipes for output
         let outputPipe = Pipe()
         let errorPipe = Pipe()
         process?.standardOutput = outputPipe
         process?.standardError = errorPipe
-        
+
         // Handle output
         outputPipe.fileHandleForReading.readabilityHandler = { [weak self] handle in
             let data = handle.availableData
@@ -175,34 +186,34 @@
                 self?.addLog(output)
             }
         }
-        
+
         errorPipe.fileHandleForReading.readabilityHandler = { [weak self] handle in
             let data = handle.availableData
             if let output = String(data: data, encoding: .utf8), !output.isEmpty {
                 self?.addLog("âš ï¸ \(output)")
             }
         }
-        
+
         // Handle termination
         process?.terminationHandler = { [weak self] process in
             // Clear pipe handlers to prevent memory leaks
             outputPipe.fileHandleForReading.readabilityHandler = nil
             errorPipe.fileHandleForReading.readabilityHandler = nil
-            
+
             DispatchQueue.main.async {
                 self?.isRunning = false
                 self?.addLog("Server stopped with code: \(process.terminationStatus)")
                 NotificationCenter.default.post(name: .serverStatusChanged, object: nil)
             }
         }
-        
+
         do {
             try process?.run()
             DispatchQueue.main.async {
                 self.isRunning = true
             }
             addLog("âœ“ Server started on port \(port)")
-            
+
             // Wait a bit to ensure it started successfully
             DispatchQueue.main.asyncAfter(deadline: .now() + Timing.readinessCheckDelay) { [weak self] in
                 guard let self = self else { return }
@@ -219,7 +230,7 @@
             completion(false)
         }
     }
-    
+
     func stop(completion: (() -> Void)? = nil) {
         guard let process = process else {
             DispatchQueue.main.async {
@@ -229,29 +240,29 @@
             }
             return
         }
-        
+
         let pid = process.processIdentifier
         addLog("Stopping server (PID: \(pid))...")
         processQueue.async { [weak self] in
             guard let self = self else { return }
-            
+
             // First try graceful termination (SIGTERM)
             process.terminate()
-            
+
             // Wait up to configured interval for graceful termination
             let deadline = Date().addingTimeInterval(Timing.gracefulTerminationTimeout)
             while process.isRunning && Date() < deadline {
                 Thread.sleep(forTimeInterval: Timing.terminationPollInterval)
             }
-            
+
             // If still running, force kill (SIGKILL)
             if process.isRunning {
                 self.addLog("âš ï¸ Server didn't stop gracefully, force killing...")
                 kill(pid, SIGKILL)
             }
-            
+
             process.waitUntilExit()
-            
+
             DispatchQueue.main.async {
                 self.process = nil
                 self.isRunning = false
@@ -261,28 +272,28 @@
             }
         }
     }
-    
+
     func runAuthCommand(_ command: AuthCommand, completion: @escaping (Bool, String) -> Void) {
         // Use bundled binary from app bundle
         guard let resourcePath = Bundle.main.resourcePath else {
             completion(false, "Could not find resource path")
             return
         }
-        
+
         let bundledPath = (resourcePath as NSString).appendingPathComponent("cli-proxy-api-plus")
         guard FileManager.default.fileExists(atPath: bundledPath) else {
             completion(false, "Binary not found at \(bundledPath)")
             return
         }
-        
+
         let authProcess = Process()
         authProcess.executableURL = URL(fileURLWithPath: bundledPath)
-        
+
         // Get the config path
         let configPath = (resourcePath as NSString).appendingPathComponent("config.yaml")
-        
+
         var qwenEmail: String?
-        
+
         switch command {
         case .claudeLogin:
             authProcess.arguments = ["--config", configPath, "-claude-login"]
@@ -297,8 +308,10 @@
             qwenEmail = email
         case .antigravityLogin:
             authProcess.arguments = ["--config", configPath, "-antigravity-login"]
+        case .kimiLogin:
+            authProcess.arguments = ["--config", configPath, "-kimi-login"]
         }
-        
+
         // Create pipes for output
         let outputPipe = Pipe()
         let errorPipe = Pipe()
@@ -306,10 +319,10 @@
         authProcess.standardOutput = outputPipe
         authProcess.standardError = errorPipe
         authProcess.standardInput = inputPipe
-        
+
         // For Copilot, we need to capture the device code from output
         let capture = OutputCapture()
-        
+
         if case .copilotLogin = command {
             outputPipe.fileHandleForReading.readabilityHandler = { handle in
                 let data = handle.availableData
@@ -319,7 +332,7 @@
                 }
             }
         }
-        
+
         // For Gemini login, automatically send newline to accept default project
         if case .geminiLogin = command {
             DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + 3.0) {
@@ -345,7 +358,7 @@
                 }
             }
         }
-        
+
         // For Qwen login, automatically send email after OAuth completes
         // NOTE: 10 second delay chosen to ensure OAuth browser flow completes before submitting email.
         // This is a conservative estimate - OAuth typically completes in 5-8 seconds, but network
@@ -362,21 +375,21 @@
                 }
             }
         }
-        
+
         // Set environment to inherit from parent
         authProcess.environment = ProcessInfo.processInfo.environment
-        
+
         do {
             NSLog("[Auth] Starting process: %@ with args: %@", bundledPath, authProcess.arguments?.joined(separator: " ") ?? "none")
             try authProcess.run()
             addLog("âœ“ Authentication process started (PID: \(authProcess.processIdentifier)) - browser should open shortly")
             NSLog("[Auth] Process started with PID: %d", authProcess.processIdentifier)
-            
+
             // Set up termination handler to detect when auth completes
             authProcess.terminationHandler = { process in
                 let exitCode = process.terminationStatus
                 NSLog("[Auth] Process terminated with exit code: %d", exitCode)
-                
+
                 if exitCode == 0 {
                     // Authentication completed successfully
                     DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
@@ -385,14 +398,14 @@
                     }
                 }
             }
-            
+
             // Wait briefly to check if process crashes immediately or to capture output
             let waitTime: TimeInterval = (command == .copilotLogin) ? 2.0 : 1.0
             DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + waitTime) {
                 if authProcess.isRunning {
                     // Process is still running - check for Copilot device code
                     NSLog("[Auth] Process running after wait, returning success")
-                    
+
                     // For Copilot, try to extract the device code from output
                     if case .copilotLogin = command {
                         // Extract code from output like "enter the code: XXXX-XXXX"
@@ -425,19 +438,19 @@
                         completion(true, "ðŸŒ Browser opened for GitHub authentication.\n\nCheck your terminal or the opened browser for the device code.\n\nThe app will automatically detect when you're authenticated.")
                         return
                     }
-                    
+
                     completion(true, "ðŸŒ Browser opened for authentication.\n\nPlease complete the login in your browser.\n\nThe app will automatically detect when you're authenticated.")
                 } else {
                     // Process died quickly - check for error
                     let outputData = try? outputPipe.fileHandleForReading.readDataToEndOfFile()
                     let errorData = try? errorPipe.fileHandleForReading.readDataToEndOfFile()
-                    
+
                     var output = String(data: outputData ?? Data(), encoding: .utf8) ?? ""
                     if output.isEmpty { output = capture.text }
                     let error = String(data: errorData ?? Data(), encoding: .utf8) ?? ""
-                    
+
                     NSLog("[Auth] Process died quickly - output: %@", output.isEmpty ? "(empty)" : String(output.prefix(200)))
-                    
+
                     if output.contains("Opening browser") || output.contains("Attempting to open URL") {
                         // Browser opened but process finished (probably success)
                         NSLog("[Auth] Browser opened, process completed")
@@ -455,23 +468,23 @@
             completion(false, "Failed to start auth process: \(error.localizedDescription)")
         }
     }
-    
+
     private func addLog(_ message: String) {
         DispatchQueue.main.async { [weak self] in
             guard let self = self else { return }
-            
+
             let timestamp = DateFormatter.localizedString(from: Date(), dateStyle: .none, timeStyle: .medium)
             let logLine = "[\(timestamp)] \(message)"
-            
+
             self.logBuffer.append(logLine)
             self.onLogUpdate?(self.logBuffer.elements())
         }
     }
-    
+
     /// Saves a Z.AI API key to the auth directory
     func saveZaiApiKey(_ apiKey: String, completion: @escaping (Bool, String) -> Void) {
         let authDir = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".cli-proxy-api")
-        
+
         // Create auth directory if needed
         do {
             try FileManager.default.createDirectory(at: authDir, withIntermediateDirectories: true)
@@ -479,13 +492,13 @@
             completion(false, "Failed to create auth directory: \(error.localizedDescription)")
             return
         }
-        
+
         // Generate unique filename with masked key for display
         let keyPreview = String(apiKey.prefix(8)) + "..." + String(apiKey.suffix(4))
         let timestamp = ISO8601DateFormatter().string(from: Date())
         let filename = "zai-\(UUID().uuidString.prefix(8)).json"
         let filePath = authDir.appendingPathComponent(filename)
-        
+
         // Create auth JSON matching the format used by other providers
         let authData: [String: Any] = [
             "type": "zai",
@@ -493,14 +506,14 @@
             "api_key": apiKey,
             "created": timestamp
         ]
-        
+
         do {
             let jsonData = try JSONSerialization.data(withJSONObject: authData, options: .prettyPrinted)
             try jsonData.write(to: filePath)
             // Set secure permissions (0600 - owner read/write only)
             try FileManager.default.setAttributes([.posixPermissions: 0o600], ofItemAtPath: filePath.path)
             addLog("âœ“ Z.AI API key saved to \(filename)")
-            
+
             // Restart server to pick up new config (getConfigPath will merge Z.AI keys)
             let wasRunning = isRunning
             if wasRunning {
@@ -510,13 +523,13 @@
                     }
                 }
             }
-            
+
             completion(true, "API key saved successfully")
         } catch {
             completion(false, "Failed to save API key: \(error.localizedDescription)")
         }
     }
-    
+
     /// Returns the config path to use, merging bundled config with Z.AI provider and provider exclusions
     func getConfigPath() -> String {
         guard let resourcePath = Bundle.main.resourcePath else {
@@ -555,7 +568,7 @@
         guard let bundledContent = try? String(contentsOfFile: bundledConfigPath, encoding: .utf8) else {
             return bundledConfigPath
         }
-        
+
         var additionalConfig = ""
 
         // Build oauth-excluded-models section for disabled providers
@@ -608,7 +621,7 @@
 
         let mergedContent = bundledContent + additionalConfig
         let mergedConfigPath = authDir.appendingPathComponent("merged-config.yaml")
-        
+
         do {
             try mergedContent.write(to: mergedConfigPath, atomically: true, encoding: .utf8)
             // Set secure permissions (0600 - owner read/write only) since config contains API keys
@@ -619,43 +632,43 @@
             return bundledConfigPath
         }
     }
-    
+
     func getLogs() -> [String] {
         return logBuffer.elements()
     }
-    
+
     /// Kill any orphaned cli-proxy-api-plus processes that might be running
     private func killOrphanedProcesses() {
         // First check if any processes exist using pgrep
         let checkTask = Process()
         checkTask.executableURL = URL(fileURLWithPath: "/usr/bin/pgrep")
         checkTask.arguments = ["-f", "cli-proxy-api-plus"]
-        
+
         let outputPipe = Pipe()
         checkTask.standardOutput = outputPipe
         checkTask.standardError = Pipe() // Suppress errors
-        
+
         do {
             try checkTask.run()
             checkTask.waitUntilExit()
-            
+
             // If pgrep found processes (exit code 0), kill them
             if checkTask.terminationStatus == 0 {
                 let data = outputPipe.fileHandleForReading.readDataToEndOfFile()
                 let output = String(data: data, encoding: .utf8) ?? ""
                 let pids = output.components(separatedBy: .newlines).filter { !$0.isEmpty }
-                
+
                 if !pids.isEmpty {
                     addLog("âš ï¸ Found orphaned server process(es): \(pids.joined(separator: ", "))")
-                    
+
                     // Now kill them
                     let killTask = Process()
                     killTask.executableURL = URL(fileURLWithPath: "/usr/bin/pkill")
                     killTask.arguments = ["-9", "-f", "cli-proxy-api-plus"]
-                    
+
                     try killTask.run()
                     killTask.waitUntilExit()
-                    
+
                     // Wait a moment for cleanup
                     Thread.sleep(forTimeInterval: 0.5)
                     addLog("âœ“ Cleaned up orphaned processes")
@@ -675,4 +688,5 @@
     case geminiLogin
     case qwenLogin(email: String)
     case antigravityLogin
+    case kimiLogin
 }
--- a/src/Sources/SettingsView.swift
+++ b/src/Sources/SettingsView.swift
@@ -6,7 +6,7 @@
     let account: AuthAccount
     let removeColor: Color
     let onRemove: () -> Void
-    
+
     var body: some View {
         HStack(spacing: 8) {
             Circle()
@@ -43,7 +43,7 @@
 struct VercelGatewayControls: View {
     @ObservedObject var serverManager: ServerManager
     @State private var showingSaved = false
-    
+
     var body: some View {
         VStack(alignment: .leading, spacing: 6) {
             Toggle(isOn: $serverManager.vercelGatewayEnabled) {
@@ -52,7 +52,7 @@
             }
             .toggleStyle(.checkbox)
             .help("Route Claude requests through Vercel AI Gateway for safer access to your Claude Max subscription")
-            
+
             if serverManager.vercelGatewayEnabled {
                 HStack(spacing: 8) {
                     Text("Vercel API key")
@@ -62,7 +62,7 @@
                         .textFieldStyle(.roundedBorder)
                         .frame(width: 220)
                         .font(.caption)
-                    
+
                     if showingSaved {
                         Text("Saved")
                             .font(.caption)
@@ -107,11 +107,11 @@
     private var activeCount: Int { accounts.filter { !$0.isExpired }.count }
     private var expiredCount: Int { accounts.filter { $0.isExpired }.count }
     private let removeColor = Color(red: 0xeb/255, green: 0x0f/255, blue: 0x0f/255)
-    
+
     private var displayTitle: String {
         customTitle ?? serviceType.displayName
     }
-    
+
     var body: some View {
         VStack(alignment: .leading, spacing: 4) {
             // Header row
@@ -147,7 +147,7 @@
                     .controlSize(.small)
                 }
             }
-            
+
             // Account display (only shown when enabled)
             if isEnabled {
                 if !accounts.isEmpty {
@@ -244,7 +244,7 @@
     @State private var zaiApiKey = ""
     @State private var pendingRefresh: DispatchWorkItem?
     @State private var expandedRowCount = 0
-    
+
     private enum Timing {
         static let serverRestartDelay: TimeInterval = 0.3
         static let refreshDebounce: TimeInterval = 0.5
@@ -395,6 +398,20 @@
                         onConnect: { showingZaiApiKeyPrompt = true },
                         onDisconnect: { account in disconnectAccount(account) },
                         onToggleEnabled: { enabled in serverManager.setProviderEnabled("zai", enabled: enabled) },
+                        onExpandChange: { expanded in expandedRowCount += expanded ? 1 : -1 }
+                    ) { EmptyView() }
+
+                    ServiceRow(
+                        serviceType: .kimi,
+                        iconName: "icon-kimi.png",
+                        accounts: authManager.accounts(for: .kimi),
+                        isAuthenticating: authenticatingService == .kimi,
+                        helpText: "Kimi (Moonshot AI) provides access to K2 and other models via OAuth device flow.",
+                        isEnabled: serverManager.isProviderEnabled("kimi"),
+                        customTitle: nil,
+                        onConnect: { connectService(.kimi) },
+                        onDisconnect: { account in disconnectAccount(account) },
+                        onToggleEnabled: { enabled in serverManager.setProviderEnabled("kimi", enabled: enabled) },
                         onExpandChange: { expanded in expandedRowCount += expanded ? 1 : -1 }
                     ) { EmptyView() }
                 }
@@ -451,7 +468,7 @@
             }
             .padding(.bottom, 12)
         }
-        .frame(width: 480, height: 740)
+        .frame(width: 480, height: 810)
         .sheet(isPresented: $showingQwenEmailPrompt) {
             VStack(spacing: 16) {
                 Text("Qwen Account Email")
@@ -520,7 +537,7 @@
     }
 
     // MARK: - Actions
-    
+
     private func openAuthFolder() {
         let authDir = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".cli-proxy-api")
         NSWorkspace.shared.open(authDir)
@@ -545,11 +562,11 @@
             launchAtLogin = SMAppService.mainApp.status == .enabled
         }
     }
-    
+
     private func connectService(_ serviceType: ServiceType) {
         authenticatingService = serviceType
         NSLog("[SettingsView] Starting %@ authentication", serviceType.displayName)
-        
+
         let command: AuthCommand
         switch serviceType {
         case .claude: command = .claudeLogin
@@ -563,13 +580,14 @@
         case .zai:
             authenticatingService = nil
             return // handled separately with API key prompt
+        case .kimi: command = .kimiLogin
         }
-        
+
         serverManager.runAuthCommand(command) { success, output in
             NSLog("[SettingsView] Auth completed - success: %d, output: %@", success, output)
             DispatchQueue.main.async {
                 self.authenticatingService = nil
-                
+
                 if success {
                     self.authResultSuccess = true
                     // For Copilot, use the output which contains the device code
@@ -587,7 +605,7 @@
             }
         }
     }
-    
+
     private func successMessage(for serviceType: ServiceType) -> String {
         switch serviceType {
         case .claude:
@@ -604,19 +622,22 @@
             return "ðŸŒ Browser opened for Antigravity authentication.\n\nPlease complete the login in your browser."
         case .zai:
             return "âœ“ Z.AI API key added successfully.\n\nYou can now use GLM models through the proxy."
+        case .kimi:
+            return "ðŸŒ Browser opened for Kimi authentication.\n\nPlease complete the login in your browser.\n\nThe app will automatically detect your credentials."
         }
     }
-    
+
+
     private func startQwenAuth(email: String) {
         authenticatingService = .qwen
         NSLog("[SettingsView] Starting Qwen authentication")
-        
+
         serverManager.runAuthCommand(.qwenLogin(email: email)) { success, output in
             NSLog("[SettingsView] Auth completed - success: %d, output: %@", success, output)
             DispatchQueue.main.async {
                 self.authenticatingService = nil
                 self.qwenEmail = ""
-                
+
                 if success {
                     self.authResultSuccess = true
                     self.authResultMessage = self.successMessage(for: .qwen)
@@ -629,17 +650,17 @@
             }
         }
     }
-    
+
     private func startZaiAuth(apiKey: String) {
         authenticatingService = .zai
         NSLog("[SettingsView] Adding Z.AI API key")
-        
+
         serverManager.saveZaiApiKey(apiKey) { success, output in
             NSLog("[SettingsView] Z.AI key save completed - success: %d, output: %@", success, output)
             DispatchQueue.main.async {
                 self.authenticatingService = nil
                 self.zaiApiKey = ""
-                
+
                 if success {
                     self.authResultSuccess = true
                     self.authResultMessage = self.successMessage(for: .zai)
@@ -653,10 +674,10 @@
             }
         }
     }
-    
+
     private func disconnectAccount(_ account: AuthAccount) {
         let wasRunning = serverManager.isRunning
-        
+
         // Stop server, delete file, restart
         let cleanup = {
             if self.authManager.deleteAccount(account) {
@@ -667,36 +688,36 @@
                 self.authResultMessage = "Failed to remove account"
             }
             self.showingAuthResult = true
-            
+
             if wasRunning {
                 DispatchQueue.main.asyncAfter(deadline: .now() + Timing.serverRestartDelay) {
                     self.serverManager.start { _ in }
                 }
             }
         }
-        
+
         if wasRunning {
             serverManager.stop { cleanup() }
         } else {
             cleanup()
         }
     }
-    
+
     // MARK: - File Monitoring
-    
+
     private func startMonitoringAuthDirectory() {
         let authDir = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".cli-proxy-api")
         try? FileManager.default.createDirectory(at: authDir, withIntermediateDirectories: true)
-        
+
         let fileDescriptor = open(authDir.path, O_EVTONLY)
         guard fileDescriptor >= 0 else { return }
-        
+
         let source = DispatchSource.makeFileSystemObjectSource(
             fileDescriptor: fileDescriptor,
             eventMask: [.write, .delete, .rename],
             queue: DispatchQueue.main
         )
-        
+
         source.setEventHandler { [self] in
             // Debounce rapid file changes to prevent UI flashing
             pendingRefresh?.cancel()
@@ -707,15 +728,15 @@
             pendingRefresh = workItem
             DispatchQueue.main.asyncAfter(deadline: .now() + Timing.refreshDebounce, execute: workItem)
         }
-        
+
         source.setCancelHandler {
             close(fileDescriptor)
         }
-        
+
         source.resume()
         fileMonitor = source
     }
-    
+
     private func stopMonitoringAuthDirectory() {
         pendingRefresh?.cancel()
         fileMonitor?.cancel()
--- a/src/Sources/ThinkingProxy.swift
+++ b/src/Sources/ThinkingProxy.swift
@@ -4,13 +4,13 @@
 /**
  A lightweight HTTP proxy that intercepts requests to add extended thinking parameters
  for Claude models based on model name suffixes.
- 
+
  Model name pattern:
  - `*-thinking-NUMBER` â†’ Custom token budget (e.g., claude-sonnet-4-5-20250929-thinking-5000)
- 
+
  The proxy strips the suffix and adds the `thinking` parameter to the request body
  before forwarding to CLIProxyAPI.
- 
+
  Examples:
  - claude-sonnet-4-5-20250929-thinking-2000 â†’ 2,000 token budget
  - claude-sonnet-4-5-20250929-thinking-8000 â†’ 8,000 token budget
@@ -29,9 +29,11 @@
     private let targetHost = "127.0.0.1"
     private(set) var isRunning = false
     private let stateQueue = DispatchQueue(label: "io.automaze.vibeproxy.thinking-proxy-state")
+    private let reasoningCacheQueue = DispatchQueue(label: "io.automaze.vibeproxy.kimi-reasoning-cache")
+    private var reasoningCache: [String: String] = [:]
 
     var vercelConfig = VercelGatewayConfig(enabled: false, apiKey: "")
-    
+
     private enum Config {
         static let hardTokenCap = 32000
         static let minimumHeadroom = 1024
@@ -39,7 +41,13 @@
         static let vercelGatewayHost = "ai-gateway.vercel.sh"
         static let anthropicVersion = "2023-06-01"
     }
-    
+
+    private final class KimiStreamState {
+        var buffer = ""
+        var reasoning = ""
+        var toolCallIDs = Set<String>()
+    }
+
     /**
      Starts the thinking proxy server on port 8317
      */
@@ -48,17 +56,17 @@
             NSLog("[ThinkingProxy] Already running")
             return
         }
-        
+
         do {
             let parameters = NWParameters.tcp
             parameters.allowLocalEndpointReuse = true
-            
+
             guard let port = NWEndpoint.Port(rawValue: proxyPort) else {
                 NSLog("[ThinkingProxy] Invalid port: %d", proxyPort)
                 return
             }
             listener = try NWListener(using: parameters, on: port)
-            
+
             listener?.stateUpdateHandler = { [weak self] state in
                 switch state {
                 case .ready:
@@ -80,25 +88,25 @@
                     break
                 }
             }
-            
+
             listener?.newConnectionHandler = { [weak self] connection in
                 self?.handleConnection(connection)
             }
-            
+
             listener?.start(queue: .global(qos: .userInitiated))
-            
+
         } catch {
             NSLog("[ThinkingProxy] Failed to start: \(error)")
         }
     }
-    
+
     /**
      Stops the thinking proxy server
      */
     func stop() {
         stateQueue.sync {
             guard isRunning else { return }
-            
+
             listener?.cancel()
             listener = nil
             DispatchQueue.main.async { [weak self] in
@@ -107,7 +115,7 @@
             NSLog("[ThinkingProxy] Stopped")
         }
     }
-    
+
     /**
      Handles an incoming connection from a client
      */
@@ -115,7 +123,7 @@
         connection.start(queue: .global(qos: .userInitiated))
         receiveRequest(from: connection)
     }
-    
+
     /**
      Receives the HTTP request from the client
      Accumulates data until full request is received (handles large payloads)
@@ -124,44 +132,44 @@
         // Start the iterative receive loop
         receiveNextChunk(from: connection, accumulatedData: accumulatedData)
     }
-    
+
     /**
      Receives request data iteratively (uses async scheduling instead of recursion to avoid stack buildup)
      */
     private func receiveNextChunk(from connection: NWConnection, accumulatedData: Data) {
         connection.receive(minimumIncompleteLength: 1, maximumLength: 1048576) { [weak self] data, _, isComplete, error in
             guard let self = self else { return }
-            
+
             if let error = error {
                 NSLog("[ThinkingProxy] Receive error: \(error)")
                 connection.cancel()
                 return
             }
-            
+
             guard let data = data, !data.isEmpty else {
                 if isComplete {
                     connection.cancel()
                 }
                 return
             }
-            
+
             var newAccumulatedData = accumulatedData
             newAccumulatedData.append(data)
-            
+
             // Check if we have a complete HTTP request
             if let requestString = String(data: newAccumulatedData, encoding: .utf8),
                let headerEndRange = requestString.range(of: "\r\n\r\n") {
-                
+
                 // Extract Content-Length if present
                 let headerEndIndex = requestString.distance(from: requestString.startIndex, to: headerEndRange.upperBound)
                 let headerPart = String(requestString.prefix(headerEndIndex))
-                
+
                 if let contentLengthLine = headerPart.components(separatedBy: "\r\n").first(where: { $0.lowercased().starts(with: "content-length:") }) {
                     let contentLengthStr = contentLengthLine.components(separatedBy: ":")[1].trimmingCharacters(in: .whitespaces)
                     if let contentLength = Int(contentLengthStr) {
                         let bodyStartIndex = headerEndIndex
                         let currentBodyLength = newAccumulatedData.count - bodyStartIndex
-                        
+
                         // If we haven't received the full body yet, schedule next iteration
                         if currentBodyLength < contentLength {
                             self.receiveNextChunk(from: connection, accumulatedData: newAccumulatedData)
@@ -169,7 +177,7 @@
                         }
                     }
                 }
-                
+
                 // We have a complete request, process it
                 self.processRequest(data: newAccumulatedData, connection: connection)
             } else if !isComplete {
@@ -181,7 +189,7 @@
             }
         }
     }
-    
+
     /**
      Processes the HTTP request, modifies it if needed, and forwards to CLIProxyAPI
      */
@@ -190,21 +198,21 @@
             sendError(to: connection, statusCode: 400, message: "Invalid request")
             return
         }
-        
+
         // Parse HTTP request
         let lines = requestString.components(separatedBy: "\r\n")
         guard let requestLine = lines.first else {
             sendError(to: connection, statusCode: 400, message: "Invalid request line")
             return
         }
-        
+
         // Extract method, path, and HTTP version
         let parts = requestLine.components(separatedBy: " ")
         guard parts.count >= 3 else {
             sendError(to: connection, statusCode: 400, message: "Invalid request format")
             return
         }
-        
+
         let method = parts[0]
         let path = parts[1]
         let httpVersion = parts[2]
@@ -220,17 +228,17 @@
             let value = String(line[valueStart...]).trimmingCharacters(in: .whitespaces)
             headers.append((name, value))
         }
-        
+
         // Find the body start
         guard let bodyStartRange = requestString.range(of: "\r\n\r\n") else {
             NSLog("[ThinkingProxy] Error: Could not find body separator in request")
             sendError(to: connection, statusCode: 400, message: "Invalid request format - no body separator")
             return
         }
-        
+
         let bodyStart = requestString.distance(from: requestString.startIndex, to: bodyStartRange.upperBound)
         let bodyString = String(requestString[requestString.index(requestString.startIndex, offsetBy: bodyStart)...])
-        
+
         // Redirect Amp CLI login directly to ampcode.com to preserve auth state cookies
         if path.starts(with: "/auth/cli-login") || path.starts(with: "/api/auth/cli-login") {
             let loginPath = path.hasPrefix("/api/") ? String(path.dropFirst(4)) : path
@@ -247,7 +255,7 @@
             rewrittenPath = "/api" + path
             NSLog("[ThinkingProxy] Rewriting Amp provider path: \(path) -> \(rewrittenPath)")
         }
-        
+
         // Check if this is an Amp management request (anything not targeting provider or /v1)
         // Note: /provider/ paths are already rewritten to /api/provider/ above
         let isProviderPath = rewrittenPath.starts(with: "/api/provider/")
@@ -258,35 +266,41 @@
             forwardToAmp(method: method, path: ampPath, version: httpVersion, headers: headers, body: bodyString, originalConnection: connection)
             return
         }
-        
+
         // Try to parse and modify JSON body for POST requests
         var modifiedBody = bodyString
         var thinkingEnabled = false
-        
+
         if method == "POST" && !bodyString.isEmpty {
             if let result = processThinkingParameter(jsonString: bodyString) {
                 modifiedBody = result.0
                 thinkingEnabled = result.1
             }
         }
-        
+
+        if method == "POST" && !modifiedBody.isEmpty {
+            if let cachedAdjusted = applyCachedKimiReasoning(jsonString: modifiedBody) {
+                modifiedBody = cachedAdjusted
+            }
+        }
+
         // Route Claude requests through Vercel AI Gateway when configured
         if vercelConfig.isActive && method == "POST" && isClaudeModelRequest(body: modifiedBody) {
             NSLog("[ThinkingProxy] Routing Claude request via Vercel AI Gateway")
             forwardToVercel(method: method, path: "/v1/messages", version: httpVersion, headers: headers, body: modifiedBody, thinkingEnabled: thinkingEnabled, originalConnection: connection)
             return
         }
-        
+
         forwardRequest(method: method, path: rewrittenPath, version: httpVersion, headers: headers, body: modifiedBody, thinkingEnabled: thinkingEnabled, originalConnection: connection)
     }
-    
+
     private func isClaudeModelRequest(body: String) -> Bool {
         guard let data = body.data(using: .utf8),
               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let model = json["model"] as? String else { return false }
         return model.starts(with: "claude-") || model.starts(with: "gemini-claude-")
     }
-    
+
     /**
      Processes the JSON body to add thinking parameter if model name has a thinking suffix
      Returns tuple of (modifiedJSON, needsTransformation)
@@ -297,20 +311,20 @@
               let model = json["model"] as? String else {
             return nil
         }
-        
+
         // Only process Claude models (including gemini-claude variants)
         guard model.starts(with: "claude-") || model.starts(with: "gemini-claude-") else {
             return (jsonString, false)  // Not Claude, pass through
         }
-        
+
         // Check for thinking suffix pattern: -thinking-NUMBER
         let thinkingPrefix = "-thinking-"
         if let thinkingRange = model.range(of: thinkingPrefix, options: .backwards),
            thinkingRange.upperBound < model.endIndex {
-            
+
             // Extract the number after "-thinking-"
             let budgetString = String(model[thinkingRange.upperBound...])
-            
+
             // For gemini-claude-* models, preserve "-thinking" and only strip the number
             // e.g. gemini-claude-opus-4-5-thinking-10000 -> gemini-claude-opus-4-5-thinking
             // For claude-* models, strip the entire suffix
@@ -322,7 +336,7 @@
                 cleanModel = String(model[..<thinkingRange.lowerBound])
             }
             json["model"] = cleanModel
-            
+
             // Only add thinking parameter if it's a valid integer
             if let budget = Int(budgetString), budget > 0 {
                 let effectiveBudget = min(budget, Config.hardTokenCap - 1)
@@ -334,7 +348,7 @@
                     "type": "enabled",
                     "budget_tokens": effectiveBudget
                 ]
-                
+
                 // Ensure max token limits are greater than the thinking budget
                 // Claude requires: max_output_tokens (or legacy max_tokens) > thinking.budget_tokens
                 let tokenHeadroom = max(Config.minimumHeadroom, Int(Double(effectiveBudget) * Config.headroomRatio))
@@ -343,24 +357,24 @@
                 if requiredMaxTokens <= effectiveBudget {
                     requiredMaxTokens = min(effectiveBudget + 1, Config.hardTokenCap)
                 }
-                
+
                 let hasMaxOutputTokensField = json.keys.contains("max_output_tokens")
                 var adjusted = false
-                
+
                 if let currentMaxTokens = json["max_tokens"] as? Int {
                     if currentMaxTokens <= effectiveBudget {
                         json["max_tokens"] = requiredMaxTokens
                     }
                     adjusted = true
                 }
-                
+
                 if let currentMaxOutputTokens = json["max_output_tokens"] as? Int {
                     if currentMaxOutputTokens <= effectiveBudget {
                         json["max_output_tokens"] = requiredMaxTokens
                     }
                     adjusted = true
                 }
-                
+
                 if !adjusted {
                     if hasMaxOutputTokensField {
                         json["max_output_tokens"] = requiredMaxTokens
@@ -368,13 +382,13 @@
                         json["max_tokens"] = requiredMaxTokens
                     }
                 }
-                
+
                 NSLog("[ThinkingProxy] Transformed model '\(model)' â†’ '\(cleanModel)' with thinking budget \(effectiveBudget)")
             } else {
                 // Invalid number - just strip suffix and use vanilla model
                 NSLog("[ThinkingProxy] Stripped invalid thinking suffix from '\(model)' â†’ '\(cleanModel)' (no thinking)")
             }
-            
+
             // Convert back to JSON
             if let modifiedData = try? JSONSerialization.data(withJSONObject: json),
                let modifiedString = String(data: modifiedData, encoding: .utf8) {
@@ -386,10 +400,62 @@
             NSLog("[ThinkingProxy] Detected thinking model '\(model)' - enabling beta header, passing through to backend")
             return (jsonString, true)
         }
-        
+
         return (jsonString, false)  // No transformation needed
     }
-    
+
+    private func applyCachedKimiReasoning(jsonString: String) -> String? {
+        guard let jsonData = jsonString.data(using: .utf8),
+              var json = try? JSONSerialization.jsonObject(with: jsonData) as? [String: Any],
+              let model = json["model"] as? String else {
+            return nil
+        }
+
+        guard model.lowercased().hasPrefix("kimi") else {
+            return nil
+        }
+
+        guard var messages = json["messages"] as? [[String: Any]] else {
+            return jsonString
+        }
+
+        var changed = false
+        for i in 0..<messages.count {
+            guard let role = messages[i]["role"] as? String, role == "assistant" else { continue }
+            guard let toolCalls = messages[i]["tool_calls"] as? [[String: Any]], !toolCalls.isEmpty else { continue }
+            if messages[i]["reasoning_content"] != nil {
+                continue
+            }
+
+            let toolCallIDs = toolCalls.compactMap { $0["id"] as? String }.filter { !$0.isEmpty }
+            if toolCallIDs.isEmpty { continue }
+
+            let cachedReasoning: String? = reasoningCacheQueue.sync {
+                for id in toolCallIDs {
+                    if let value = reasoningCache[id], !value.isEmpty {
+                        return value
+                    }
+                }
+                return nil
+            }
+
+            if let cachedReasoning {
+                messages[i]["reasoning_content"] = cachedReasoning
+                changed = true
+            }
+        }
+
+        if changed {
+            json["messages"] = messages
+            if let modifiedData = try? JSONSerialization.data(withJSONObject: json),
+               let modifiedString = String(data: modifiedData, encoding: .utf8) {
+                return modifiedString
+            }
+        }
+
+        return jsonString
+    }
+
     /**
      Forwards Amp API requests to ampcode.com, stripping the /api/ prefix
      */
@@ -397,17 +463,17 @@
         // Create TLS parameters for HTTPS
         let tlsOptions = NWProtocolTLS.Options()
         let parameters = NWParameters(tls: tlsOptions, tcp: NWProtocolTCP.Options())
-        
+
         // Create connection to ampcode.com:443
         let endpoint = NWEndpoint.hostPort(host: "ampcode.com", port: 443)
         let targetConnection = NWConnection(to: endpoint, using: parameters)
-        
+
         targetConnection.stateUpdateHandler = { state in
             switch state {
             case .ready:
                 // Build the forwarded request
                 var forwardedRequest = "\(method) \(path) \(version)\r\n"
-                
+
                 // Forward most headers, excluding some that need to be overridden
                 let excludedHeaders: Set<String> = ["host", "content-length", "connection", "transfer-encoding"]
                 for (name, value) in headers {
@@ -415,16 +481,16 @@
                         forwardedRequest += "\(name): \(value)\r\n"
                     }
                 }
-                
+
                 // Override Host header for ampcode.com
                 forwardedRequest += "Host: ampcode.com\r\n"
                 forwardedRequest += "Connection: close\r\n"
-                
+
                 let contentLength = body.utf8.count
                 forwardedRequest += "Content-Length: \(contentLength)\r\n"
                 forwardedRequest += "\r\n"
                 forwardedRequest += body
-                
+
                 // Send to ampcode.com
                 if let requestData = forwardedRequest.data(using: .utf8) {
                     targetConnection.send(content: requestData, completion: .contentProcessed({ error in
@@ -438,34 +504,34 @@
                         }
                     }))
                 }
-                
+
             case .failed(let error):
                 NSLog("[ThinkingProxy] Connection to ampcode.com failed: \(error)")
                 self.sendError(to: originalConnection, statusCode: 502, message: "Bad Gateway - Could not connect to ampcode.com")
                 targetConnection.cancel()
-                
+
             default:
                 break
             }
         }
-        
+
         targetConnection.start(queue: .global(qos: .userInitiated))
     }
-    
+
     /**
      Receives response from ampcode.com and rewrites Location headers to add /api/ prefix
      */
     private func receiveAmpResponse(from targetConnection: NWConnection, originalConnection: NWConnection) {
         targetConnection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { [weak self] data, _, isComplete, error in
             guard let self = self else { return }
-            
+
             if let error = error {
                 NSLog("[ThinkingProxy] Receive Amp response error: \(error)")
                 targetConnection.cancel()
                 originalConnection.cancel()
                 return
             }
-            
+
             if let data = data, !data.isEmpty {
                 // Convert to string to rewrite headers
                 if var responseString = String(data: data, encoding: .utf8) {
@@ -503,13 +569,13 @@
                         with: "Domain=localhost",
                         options: .caseInsensitive
                     )
-                    
+
                     if let modifiedData = responseString.data(using: .utf8) {
                         originalConnection.send(content: modifiedData, completion: .contentProcessed({ sendError in
                             if let sendError = sendError {
                                 NSLog("[ThinkingProxy] Send Amp response error: \(sendError)")
                             }
-                            
+
                             if isComplete {
                                 targetConnection.cancel()
                                 originalConnection.send(content: nil, isComplete: true, completion: .contentProcessed({ _ in
@@ -527,7 +593,7 @@
                         if let sendError = sendError {
                             NSLog("[ThinkingProxy] Send Amp response error: \(sendError)")
                         }
-                        
+
                         if isComplete {
                             targetConnection.cancel()
                             originalConnection.send(content: nil, isComplete: true, completion: .contentProcessed({ _ in
@@ -546,27 +612,27 @@
             }
         }
     }
-    
+
     /**
      Forwards Claude requests to Vercel AI Gateway (ai-gateway.vercel.sh)
      */
     private func forwardToVercel(method: String, path: String, version: String, headers: [(String, String)], body: String, thinkingEnabled: Bool, originalConnection: NWConnection) {
         let tlsOptions = NWProtocolTLS.Options()
         let parameters = NWParameters(tls: tlsOptions, tcp: NWProtocolTCP.Options())
-        
+
         let endpoint = NWEndpoint.hostPort(host: NWEndpoint.Host(Config.vercelGatewayHost), port: 443)
         let targetConnection = NWConnection(to: endpoint, using: parameters)
         let apiKey = vercelConfig.apiKey
-        
+
         targetConnection.stateUpdateHandler = { [weak self] state in
             guard let self = self else { return }
             switch state {
             case .ready:
                 var forwardedRequest = "\(method) \(path) \(version)\r\n"
-                
+
                 let excludedHeaders: Set<String> = ["host", "content-length", "connection", "transfer-encoding", "authorization", "x-api-key"]
                 var existingBetaHeader: String? = nil
-                
+
                 for (name, value) in headers {
                     let lower = name.lowercased()
                     if excludedHeaders.contains(lower) { continue }
@@ -576,12 +642,12 @@
                     }
                     forwardedRequest += "\(name): \(value)\r\n"
                 }
-                
+
                 // Vercel auth
                 forwardedRequest += "x-api-key: \(apiKey)\r\n"
                 forwardedRequest += "anthropic-version: \(Config.anthropicVersion)\r\n"
                 forwardedRequest += "content-type: application/json\r\n"
-                
+
                 // Thinking beta header
                 if thinkingEnabled {
                     var betaValue = BetaHeaders.interleavedThinking
@@ -592,15 +658,15 @@
                 } else if let existing = existingBetaHeader {
                     forwardedRequest += "anthropic-beta: \(existing)\r\n"
                 }
-                
+
                 forwardedRequest += "Host: \(Config.vercelGatewayHost)\r\n"
                 forwardedRequest += "Connection: close\r\n"
-                
+
                 let contentLength = body.utf8.count
                 forwardedRequest += "Content-Length: \(contentLength)\r\n"
                 forwardedRequest += "\r\n"
                 forwardedRequest += body
-                
+
                 if let requestData = forwardedRequest.data(using: .utf8) {
                     targetConnection.send(content: requestData, completion: .contentProcessed({ error in
                         if let error = error {
@@ -612,24 +678,24 @@
                         }
                     }))
                 }
-                
+
             case .failed(let error):
                 NSLog("[ThinkingProxy] Vercel connection failed: \(error)")
                 self.sendError(to: originalConnection, statusCode: 502, message: "Bad Gateway - Could not connect to Vercel AI Gateway")
                 targetConnection.cancel()
-                
+
             default:
                 break
             }
         }
-        
+
         targetConnection.start(queue: .global(qos: .userInitiated))
     }
-    
+
     private enum BetaHeaders {
         static let interleavedThinking = "interleaved-thinking-2025-05-14"
     }
-    
+
     /**
      Forwards the request to CLIProxyAPI on port 8318 (pass-through for non-thinking requests)
      */
@@ -643,7 +709,7 @@
         let endpoint = NWEndpoint.hostPort(host: NWEndpoint.Host(targetHost), port: port)
         let parameters = NWParameters.tcp
         let targetConnection = NWConnection(to: endpoint, using: parameters)
-        
+
         targetConnection.stateUpdateHandler = { state in
             switch state {
             case .ready:
@@ -651,7 +717,7 @@
                 var forwardedRequest = "\(method) \(path) \(version)\r\n"
                 let excludedHeaders: Set<String> = ["content-length", "host", "transfer-encoding"]
                 var existingBetaHeader: String? = nil
-                
+
                 for (name, value) in headers {
                     let lowercasedName = name.lowercased()
                     if excludedHeaders.contains(lowercasedName) {
@@ -664,7 +730,7 @@
                     }
                     forwardedRequest += "\(name): \(value)\r\n"
                 }
-                
+
                 // Add/merge anthropic-beta header when thinking is enabled
                 if thinkingEnabled {
                     var betaValue = BetaHeaders.interleavedThinking
@@ -682,17 +748,17 @@
                     // Pass through existing header when thinking not enabled
                     forwardedRequest += "anthropic-beta: \(existing)\r\n"
                 }
-                
+
                 // Override Host header
                 forwardedRequest += "Host: \(self.targetHost):\(self.targetPort)\r\n"
                 // Always close connections - this proxy doesn't support keep-alive/pipelining
                 forwardedRequest += "Connection: close\r\n"
-                
+
                 let contentLength = body.utf8.count
                 forwardedRequest += "Content-Length: \(contentLength)\r\n"
                 forwardedRequest += "\r\n"
                 forwardedRequest += body
-                
+
                 // Send to CLIProxyAPI
                 if let requestData = forwardedRequest.data(using: .utf8) {
                     targetConnection.send(content: requestData, completion: .contentProcessed({ error in
@@ -703,8 +769,8 @@
                         } else {
                             // Receive response from CLIProxyAPI (with 404 retry capability)
                             if retryWithApiPrefix {
-                                self.receiveResponseWith404Retry(from: targetConnection, originalConnection: originalConnection, 
-                                                                 method: method, path: path, version: version, 
+                                self.receiveResponseWith404Retry(from: targetConnection, originalConnection: originalConnection,
+                                                                 method: method, path: path, version: version,
                                                                  headers: headers, body: body)
                             } else {
                                 self.receiveResponse(from: targetConnection, originalConnection: originalConnection)
@@ -712,69 +778,71 @@
                         }
                     }))
                 }
-                
+
             case .failed(let error):
                 NSLog("[ThinkingProxy] Target connection failed: \(error)")
                 self.sendError(to: originalConnection, statusCode: 502, message: "Bad Gateway")
                 targetConnection.cancel()
-                
+
             default:
                 break
             }
         }
-        
+
         targetConnection.start(queue: .global(qos: .userInitiated))
     }
-    
+
     /**
      Receives response and retries with /api/ prefix on 404
      */
-    private func receiveResponseWith404Retry(from targetConnection: NWConnection, originalConnection: NWConnection, 
-                                             method: String, path: String, version: String, 
+    private func receiveResponseWith404Retry(from targetConnection: NWConnection, originalConnection: NWConnection,
+                                             method: String, path: String, version: String,
                                              headers: [(String, String)], body: String) {
+        let streamState = KimiStreamState()
         targetConnection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { [weak self] data, _, isComplete, error in
             guard let self = self else { return }
-            
+
             if let error = error {
                 NSLog("[ThinkingProxy] Receive error: \(error)")
                 targetConnection.cancel()
                 originalConnection.cancel()
                 return
             }
-            
+
             if let data = data, !data.isEmpty {
                 // Check if response is a 404
                 if let responseString = String(data: data, encoding: .utf8) {
                     // Log first 200 chars to debug
                     let preview = String(responseString.prefix(200))
                     NSLog("[ThinkingProxy] Response preview for \(path): \(preview)")
-                    
+
                     // Check for 404 in status line OR in body
-                    let is404 = responseString.contains("HTTP/1.1 404") || 
+                    let is404 = responseString.contains("HTTP/1.1 404") ||
                                responseString.contains("HTTP/1.0 404") ||
                                responseString.contains("404 page not found")
-                    
+
                     if is404 {
                         // Check if path doesn't already start with /api/
                         if !path.starts(with: "/api/") && !path.starts(with: "/v1/") {
                             NSLog("[ThinkingProxy] Got 404 for \(path), retrying with /api prefix")
                             targetConnection.cancel()
-                            
+
                             // Retry with /api/ prefix
                             let newPath = "/api" + path
-                            self.forwardRequest(method: method, path: newPath, version: version, headers: headers, 
+                            self.forwardRequest(method: method, path: newPath, version: version, headers: headers,
                                               body: body, originalConnection: originalConnection, retryWithApiPrefix: false)
                             return
                         }
                     }
                 }
-                
+
                 // Not a 404 or already has /api/, forward response as-is
+                self.captureKimiReasoning(from: data, state: streamState)
                 originalConnection.send(content: data, completion: .contentProcessed({ sendError in
                     if let sendError = sendError {
                         NSLog("[ThinkingProxy] Send error: \(sendError)")
                     }
-                    
+
                     if isComplete {
                         targetConnection.cancel()
                         originalConnection.send(content: nil, isComplete: true, completion: .contentProcessed({ _ in
@@ -782,7 +850,7 @@
                         }))
                     } else {
                         // Continue streaming
-                        self.streamNextChunk(from: targetConnection, to: originalConnection)
+                        self.streamNextChunk(from: targetConnection, to: originalConnection, streamState: streamState)
                     }
                 }))
             } else if isComplete {
@@ -793,37 +861,41 @@
             }
         }
     }
-    
+
     /**
      Receives response from CLIProxyAPI
      Starts the streaming loop for response data
      */
     private func receiveResponse(from targetConnection: NWConnection, originalConnection: NWConnection) {
         // Start the streaming loop
-        streamNextChunk(from: targetConnection, to: originalConnection)
+        let streamState = KimiStreamState()
+        streamNextChunk(from: targetConnection, to: originalConnection, streamState: streamState)
     }
-    
+
     /**
      Streams response chunks iteratively (uses async scheduling instead of recursion to avoid stack buildup)
      */
-    private func streamNextChunk(from targetConnection: NWConnection, to originalConnection: NWConnection) {
+    private func streamNextChunk(from targetConnection: NWConnection, to originalConnection: NWConnection, streamState: KimiStreamState? = nil) {
         targetConnection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { [weak self] data, _, isComplete, error in
             guard let self = self else { return }
-            
+
             if let error = error {
                 NSLog("[ThinkingProxy] Receive response error: \(error)")
                 targetConnection.cancel()
                 originalConnection.cancel()
                 return
             }
-            
+
             if let data = data, !data.isEmpty {
+                if let streamState = streamState {
+                    self.captureKimiReasoning(from: data, state: streamState)
+                }
                 // Forward response chunk to original client
                 originalConnection.send(content: data, completion: .contentProcessed({ sendError in
                     if let sendError = sendError {
                         NSLog("[ThinkingProxy] Send response error: \(sendError)")
                     }
-                    
+
                     if isComplete {
                         targetConnection.cancel()
                         // Always close client connection - no keep-alive/pipelining support
@@ -832,7 +904,7 @@
                         }))
                     } else {
                         // Schedule next iteration of the streaming loop
-                        self.streamNextChunk(from: targetConnection, to: originalConnection)
+                        self.streamNextChunk(from: targetConnection, to: originalConnection, streamState: streamState)
                     }
                 }))
             } else if isComplete {
@@ -844,7 +916,92 @@
             }
         }
     }
-    
+
+    private func captureKimiReasoning(from data: Data, state: KimiStreamState) {
+        guard let text = String(data: data, encoding: .utf8) else { return }
+        state.buffer += text.replacingOccurrences(of: "\r", with: "")
+
+        while let range = state.buffer.range(of: "\n\n") {
+            let event = String(state.buffer[..<range.lowerBound])
+            state.buffer.removeSubrange(state.buffer.startIndex..<range.upperBound)
+            let lines = event.split(separator: "\n", omittingEmptySubsequences: false)
+            for line in lines {
+                let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
+                guard trimmed.hasPrefix("data:") else { continue }
+                let payload = trimmed.dropFirst(5).trimmingCharacters(in: .whitespaces)
+                if payload == "[DONE]" || payload.isEmpty { continue }
+                handleKimiSSEPayload(String(payload), state: state)
+            }
+        }
+    }
+
+    private func handleKimiSSEPayload(_ payload: String, state: KimiStreamState) {
+        guard let jsonData = payload.data(using: .utf8),
+              let json = try? JSONSerialization.jsonObject(with: jsonData) as? [String: Any] else {
+            return
+        }
+
+        if let model = json["model"] as? String, !model.lowercased().hasPrefix("kimi") {
+            return
+        }
+
+        guard let choices = json["choices"] as? [[String: Any]], let choice = choices.first else {
+            return
+        }
+
+        if let delta = choice["delta"] as? [String: Any] {
+            if let reasoning = delta["reasoning_content"] as? String {
+                state.reasoning += reasoning
+            }
+            if let toolCalls = delta["tool_calls"] as? [[String: Any]] {
+                for toolCall in toolCalls {
+                    if let id = toolCall["id"] as? String, !id.isEmpty {
+                        state.toolCallIDs.insert(id)
+                    }
+                }
+            }
+        }
+
+        if let message = choice["message"] as? [String: Any] {
+            if let reasoning = message["reasoning_content"] as? String {
+                state.reasoning += reasoning
+            }
+            if let toolCalls = message["tool_calls"] as? [[String: Any]] {
+                for toolCall in toolCalls {
+                    if let id = toolCall["id"] as? String, !id.isEmpty {
+                        state.toolCallIDs.insert(id)
+                    }
+                }
+            }
+        }
+
+        if let finishReason = choice["finish_reason"] as? String, !finishReason.isEmpty {
+            commitKimiReasoningCache(state: state)
+        }
+    }
+
+    private func commitKimiReasoningCache(state: KimiStreamState) {
+        let reasoning = state.reasoning
+        let toolCallIDs = state.toolCallIDs
+        state.reasoning = ""
+        state.toolCallIDs.removeAll()
+
+        let trimmed = reasoning.trimmingCharacters(in: .whitespacesAndNewlines)
+        guard !trimmed.isEmpty, !toolCallIDs.isEmpty else { return }
+
+        reasoningCacheQueue.async {
+            for id in toolCallIDs {
+                self.reasoningCache[id] = reasoning
+            }
+            if self.reasoningCache.count > 2000 {
+                let keys = Array(self.reasoningCache.keys.prefix(500))
+                for key in keys {
+                    self.reasoningCache.removeValue(forKey: key)
+                }
+            }
+        }
+    }
+
     /**
      Sends an error response to the client
      */
@@ -854,22 +1011,22 @@
             connection.cancel()
             return
         }
-        
+
         let headers = "HTTP/1.1 \(statusCode) \(message)\r\n" +
                      "Content-Type: text/plain\r\n" +
                      "Content-Length: \(bodyData.count)\r\n" +
                      "Connection: close\r\n" +
                      "\r\n"
-        
+
         guard let headerData = headers.data(using: .utf8) else {
             connection.cancel()
             return
         }
-        
+
         var responseData = Data()
         responseData.append(headerData)
         responseData.append(bodyData)
-        
+
         connection.send(content: responseData, completion: .contentProcessed({ _ in
             connection.cancel()
         }))
@@ -891,4 +1048,5 @@
             connection.cancel()
         }))
     }
+
 }
